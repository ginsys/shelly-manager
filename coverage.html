
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>shelly-manager: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ginsys/shelly-manager/cmd/shelly-manager/main.go (6.5%)</option>
				
				<option value="file1">github.com/ginsys/shelly-manager/internal/api/handlers.go (77.8%)</option>
				
				<option value="file2">github.com/ginsys/shelly-manager/internal/api/router.go (100.0%)</option>
				
				<option value="file3">github.com/ginsys/shelly-manager/internal/config/config.go (0.0%)</option>
				
				<option value="file4">github.com/ginsys/shelly-manager/internal/database/database.go (94.4%)</option>
				
				<option value="file5">github.com/ginsys/shelly-manager/internal/discovery/discovery.go (79.7%)</option>
				
				<option value="file6">github.com/ginsys/shelly-manager/internal/discovery/mdns.go (0.0%)</option>
				
				<option value="file7">github.com/ginsys/shelly-manager/internal/service/service.go (0.0%)</option>
				
				<option value="file8">github.com/ginsys/shelly-manager/internal/testutil/testutil.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "os"
        "strings"
        "time"

        "github.com/ginsys/shelly-manager/internal/api"
        "github.com/ginsys/shelly-manager/internal/config"
        "github.com/ginsys/shelly-manager/internal/database"
        "github.com/ginsys/shelly-manager/internal/service"
        "github.com/spf13/cobra"
        "gorm.io/gorm"
)

// Global variables
var (
        shellyService *service.ShellyService
        dbManager     *database.Manager
        cfg           *config.Config
        configFile    string
)

// Root command
var rootCmd = &amp;cobra.Command{
        Use:   "shelly-manager",
        Short: "Manage Shelly IoT devices",
        Long: `A comprehensive tool for discovering, configuring, and managing 
Shelly smart home devices on your network.`,
}

// CLI Commands
var listCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List all devices",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                devices, err := dbManager.GetDevices()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("Error fetching devices:", err)
                }</span>
                
                <span class="cov0" title="0">fmt.Printf("%-5s %-15s %-18s %-12s %-20s %-10s\n", 
                        "ID", "IP", "MAC", "Type", "Name", "Status")
                fmt.Println(strings.Repeat("-", 80))
                
                for _, device := range devices </span><span class="cov0" title="0">{
                        fmt.Printf("%-5d %-15s %-18s %-12s %-20s %-10s\n",
                                device.ID, device.IP, device.MAC, device.Type, device.Name, device.Status)
                }</span>
        },
}

var discoverCmd = &amp;cobra.Command{
        Use:   "discover [network]",
        Short: "Discover devices on network",
        Args:  cobra.MaximumNArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                var network string
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        network = args[0]
                }</span> else<span class="cov0" title="0"> {
                        // Use "auto" to trigger config-based discovery
                        network = "auto"
                }</span>
                
                <span class="cov0" title="0">if network == "auto" &amp;&amp; len(cfg.Discovery.Networks) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("Discovering devices on configured networks: %v\n", cfg.Discovery.Networks)
                }</span> else<span class="cov0" title="0"> if network != "auto" </span><span class="cov0" title="0">{
                        fmt.Printf("Discovering devices on network %s...\n", network)
                }</span>
                
                <span class="cov0" title="0">devices, err := shellyService.DiscoverDevices(network)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("Discovery failed:", err)
                }</span>
                
                <span class="cov0" title="0">fmt.Printf("\nFound %d devices:\n", len(devices))
                fmt.Println(strings.Repeat("-", 80))
                
                for _, device := range devices </span><span class="cov0" title="0">{
                        fmt.Printf("IP: %-15s  MAC: %s\n", device.IP, device.MAC)
                        fmt.Printf("Type: %-20s  Firmware: %s\n", device.Type, device.Firmware)
                        fmt.Printf("Name: %s\n", device.Name)
                        
                        // Parse settings to show more info
                        var settings map[string]interface{}
                        if err := json.Unmarshal([]byte(device.Settings), &amp;settings); err == nil </span><span class="cov0" title="0">{
                                if model, ok := settings["model"].(string); ok </span><span class="cov0" title="0">{
                                        fmt.Printf("Model: %s", model)
                                        if gen, ok := settings["gen"].(float64); ok </span><span class="cov0" title="0">{
                                                fmt.Printf(" (Gen %d)", int(gen))
                                        }</span>
                                        <span class="cov0" title="0">if auth, ok := settings["auth_enabled"].(bool); ok &amp;&amp; auth </span><span class="cov0" title="0">{
                                                fmt.Printf(" [Auth Required]")
                                        }</span>
                                        <span class="cov0" title="0">fmt.Println()</span>
                                }
                        }
                        
                        // Check if device already exists by MAC
                        <span class="cov0" title="0">_, err := dbManager.GetDeviceByMAC(device.MAC)
                        if err != nil &amp;&amp; err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                                if err := dbManager.AddDevice(&amp;device); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Failed to add device %s: %v", device.IP, err)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("✓ Added to database\n")
                                }</span>
                        } else<span class="cov0" title="0"> if err == nil </span><span class="cov0" title="0">{
                                // Update existing device with new IP if changed
                                existingDevice, _ := dbManager.GetDeviceByMAC(device.MAC)
                                if existingDevice.IP != device.IP </span><span class="cov0" title="0">{
                                        existingDevice.IP = device.IP
                                        existingDevice.LastSeen = time.Now()
                                        dbManager.UpdateDevice(existingDevice)
                                        fmt.Printf("✓ Updated IP address in database\n")
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("• Already in database\n")
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Println(strings.Repeat("-", 80))</span>
                }
        },
}

var addCmd = &amp;cobra.Command{
        Use:   "add &lt;ip&gt; [name]",
        Short: "Add a device by IP address",
        Args:  cobra.RangeArgs(1, 2),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                ip := args[0]
                name := "Unknown Device"
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        name = args[1]
                }</span>
                
                // Try to discover the specific device first
                <span class="cov0" title="0">devices, err := shellyService.DiscoverDevices(ip + "/32")
                if err != nil || len(devices) == 0 </span><span class="cov0" title="0">{
                        log.Fatal("Could not discover device at", ip)
                }</span>
                
                <span class="cov0" title="0">device := devices[0]
                if name != "Unknown Device" </span><span class="cov0" title="0">{
                        device.Name = name
                }</span>
                
                <span class="cov0" title="0">if err := dbManager.AddDevice(&amp;device); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("Failed to add device:", err)
                }</span>
                
                <span class="cov0" title="0">fmt.Printf("Added device: %s (%s) at %s\n", device.Name, device.Type, device.IP)</span>
        },
}

var provisionCmd = &amp;cobra.Command{
        Use:   "provision",
        Short: "Provision unconfigured devices",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Println("Device provisioning is not yet implemented")
                fmt.Println("This feature will configure unconfigured Shelly devices found in AP mode")
        }</span>,
}

var serverCmd = &amp;cobra.Command{
        Use:   "server",
        Short: "Start the HTTP API server",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                startServer()
        }</span>,
}

// startServer starts the HTTP API server
func startServer() <span class="cov0" title="0">{
        // Create API handler
        apiHandler := api.NewHandler(dbManager)
        
        // Setup routes
        router := api.SetupRoutes(apiHandler)
        
        // Start server
        address := fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.Port)
        fmt.Printf("Starting server on %s\n", address)
        fmt.Printf("Web interface: http://%s\n", address)
        fmt.Printf("API base URL: http://%s/api/v1\n", address)
        
        if err := http.ListenAndServe(address, router); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Server failed to start:", err)
        }</span>
}

// Initialize configuration, database, and services
func initApp() <span class="cov0" title="0">{
        var err error
        
        // Load configuration
        cfg, err = config.Load(configFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to load config:", err)
        }</span>
        
        // Initialize database
        <span class="cov0" title="0">dbManager, err = database.NewManager(cfg.Database.Path)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to initialize database:", err)
        }</span>
        
        // Initialize service
        <span class="cov0" title="0">shellyService = service.NewService(dbManager, cfg)
        
        fmt.Printf("Shelly Manager initialized\n")
        fmt.Printf("Database: %s\n", cfg.Database.Path)
        if len(cfg.Discovery.Networks) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Discovery networks: %v\n", cfg.Discovery.Networks)
        }</span>
}

func init() <span class="cov8" title="1">{
        // Add persistent flags
        rootCmd.PersistentFlags().StringVar(&amp;configFile, "config", "", 
                "config file (default is shelly-manager.yaml)")
        
        // Add subcommands
        rootCmd.AddCommand(listCmd)
        rootCmd.AddCommand(discoverCmd)
        rootCmd.AddCommand(addCmd)
        rootCmd.AddCommand(provisionCmd)
        rootCmd.AddCommand(serverCmd)
}</span>

func main() <span class="cov0" title="0">{
        // Initialize before running commands
        cobra.OnInitialize(initApp)
        
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "encoding/json"
        "net/http"
        "strconv"

        "github.com/ginsys/shelly-manager/internal/database"
        "github.com/gorilla/mux"
        "gorm.io/gorm"
)

// Handler contains dependencies for API handlers
type Handler struct {
        DB *database.Manager
}

// NewHandler creates a new API handler
func NewHandler(db *database.Manager) *Handler <span class="cov8" title="1">{
        return &amp;Handler{DB: db}
}</span>

// GetDevices handles GET /api/v1/devices
func (h *Handler) GetDevices(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        devices, err := h.DB.GetDevices()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(devices)</span>
}

// AddDevice handles POST /api/v1/devices
func (h *Handler) AddDevice(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var device database.Device
        if err := json.NewDecoder(r.Body).Decode(&amp;device); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := h.DB.AddDevice(&amp;device); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(device)</span>
}

// GetDevice handles GET /api/v1/devices/{id}
func (h *Handler) GetDevice(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id, err := strconv.ParseUint(vars["id"], 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "Invalid device ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">device, err := h.DB.GetDevice(uint(id))
        if err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        http.Error(w, "Device not found", http.StatusNotFound)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(device)</span>
}

// UpdateDevice handles PUT /api/v1/devices/{id}
func (h *Handler) UpdateDevice(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id, err := strconv.ParseUint(vars["id"], 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid device ID", http.StatusBadRequest)
                return
        }</span>

        // Check if device exists
        <span class="cov8" title="1">existingDevice, err := h.DB.GetDevice(uint(id))
        if err != nil </span><span class="cov8" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov8" title="1">{
                        http.Error(w, "Device not found", http.StatusNotFound)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // Decode updated device data
        <span class="cov8" title="1">var updatedDevice database.Device
        if err := json.NewDecoder(r.Body).Decode(&amp;updatedDevice); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        // Update existing device with new data
        <span class="cov8" title="1">updatedDevice.ID = existingDevice.ID
        if err := h.DB.UpdateDevice(&amp;updatedDevice); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(updatedDevice)</span>
}

// DeleteDevice handles DELETE /api/v1/devices/{id}
func (h *Handler) DeleteDevice(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id, err := strconv.ParseUint(vars["id"], 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid device ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := h.DB.DeleteDevice(uint(id)); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

// DiscoverHandler handles POST /api/v1/discover
func (h *Handler) DiscoverHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // This will be implemented when we integrate with the discovery service
        response := map[string]interface{}{
                "status":  "discovery_started",
                "message": "Device discovery has been initiated",
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

// GetProvisioningStatus handles GET /api/v1/provisioning/status
func (h *Handler) GetProvisioningStatus(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        status := map[string]interface{}{
                "status":      "idle",
                "devices":     []string{},
                "last_run":    nil,
                "next_run":    nil,
                "auto_provision": false,
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(status)
}</span>

// ProvisionDevices handles POST /api/v1/provisioning/provision
func (h *Handler) ProvisionDevices(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        response := map[string]interface{}{
                "status":  "provisioning_started",
                "message": "Device provisioning has been initiated",
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
}</span>

// GetDHCPReservations handles GET /api/v1/dhcp/reservations
func (h *Handler) GetDHCPReservations(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        reservations := []map[string]interface{}{}

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(reservations)
}</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "net/http"

        "github.com/gorilla/mux"
)

// SetupRoutes configures all API routes
func SetupRoutes(handler *Handler) *mux.Router <span class="cov8" title="1">{
        r := mux.NewRouter()

        // API routes
        api := r.PathPrefix("/api/v1").Subrouter()
        
        // Device routes
        api.HandleFunc("/devices", handler.GetDevices).Methods("GET")
        api.HandleFunc("/devices", handler.AddDevice).Methods("POST")
        api.HandleFunc("/devices/{id}", handler.GetDevice).Methods("GET")
        api.HandleFunc("/devices/{id}", handler.UpdateDevice).Methods("PUT")
        api.HandleFunc("/devices/{id}", handler.DeleteDevice).Methods("DELETE")
        
        // Discovery route
        api.HandleFunc("/discover", handler.DiscoverHandler).Methods("POST")
        
        // Provisioning routes
        api.HandleFunc("/provisioning/status", handler.GetProvisioningStatus).Methods("GET")
        api.HandleFunc("/provisioning/provision", handler.ProvisionDevices).Methods("POST")
        
        // DHCP routes
        api.HandleFunc("/dhcp/reservations", handler.GetDHCPReservations).Methods("GET")

        // Static file serving
        r.PathPrefix("/web/").Handler(http.StripPrefix("/web/", http.FileServer(http.Dir("./web/static/"))))
        r.PathPrefix("/").Handler(http.StripPrefix("/", http.FileServer(http.Dir("./web/static/"))))

        return r
}</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "fmt"
        "path/filepath"
        "runtime"

        "github.com/spf13/viper"
)

// Config represents the application configuration
type Config struct {
        Server struct {
                Port     int    `mapstructure:"port"`
                Host     string `mapstructure:"host"`
                LogLevel string `mapstructure:"log_level"`
        } `mapstructure:"server"`
        Database struct {
                Path string `mapstructure:"path"`
        } `mapstructure:"database"`
        Discovery struct {
                Enabled          bool     `mapstructure:"enabled"`
                Networks         []string `mapstructure:"networks"`
                Interval         int      `mapstructure:"interval"`
                Timeout          int      `mapstructure:"timeout"`
                EnableMDNS       bool     `mapstructure:"enable_mdns"`
                EnableSSDP       bool     `mapstructure:"enable_ssdp"`
                ConcurrentScans  int      `mapstructure:"concurrent_scans"`
        } `mapstructure:"discovery"`
        Provisioning struct {
                AuthEnabled        bool   `mapstructure:"auth_enabled"`
                AuthUser          string `mapstructure:"auth_user"`
                AuthPassword      string `mapstructure:"auth_password"`
                CloudEnabled      bool   `mapstructure:"cloud_enabled"`
                MQTTEnabled       bool   `mapstructure:"mqtt_enabled"`
                MQTTServer        string `mapstructure:"mqtt_server"`
                DeviceNamePattern string `mapstructure:"device_name_pattern"`
                AutoProvision     bool   `mapstructure:"auto_provision"`
                ProvisionInterval int    `mapstructure:"provision_interval"`
        } `mapstructure:"provisioning"`
        DHCP struct {
                Network   string `mapstructure:"network"`
                StartIP   string `mapstructure:"start_ip"`
                EndIP     string `mapstructure:"end_ip"`
                AutoReserve bool `mapstructure:"auto_reserve"`
        } `mapstructure:"dhcp"`
        OPNSense struct {
                Enabled   bool   `mapstructure:"enabled"`
                Host      string `mapstructure:"host"`
                Port      int    `mapstructure:"port"`
                APIKey    string `mapstructure:"api_key"`
                APISecret string `mapstructure:"api_secret"`
                AutoApply bool   `mapstructure:"auto_apply"`
        } `mapstructure:"opnsense"`
        MainApp struct {
                URL     string `mapstructure:"url"`
                APIKey  string `mapstructure:"api_key"`
                Enabled bool   `mapstructure:"enabled"`
        } `mapstructure:"main_app"`
}

// Load loads configuration from file
func Load(configFile string) (*Config, error) <span class="cov0" title="0">{
        if configFile != "" </span><span class="cov0" title="0">{
                viper.SetConfigFile(configFile)
        }</span> else<span class="cov0" title="0"> {
                // Default configuration search paths
                viper.SetConfigName("shelly-manager")
                viper.SetConfigType("yaml")
                viper.AddConfigPath(".")
                viper.AddConfigPath("./configs")
                viper.AddConfigPath("$HOME/.shelly-manager")
                viper.AddConfigPath("/etc/shelly-manager")
                
                // Add current directory based on executable location
                if _, filename, _, ok := runtime.Caller(0); ok </span><span class="cov0" title="0">{
                        configDir := filepath.Dir(filepath.Dir(filepath.Dir(filename))) // Go up to project root
                        viper.AddConfigPath(filepath.Join(configDir, "configs"))
                }</span>
        }

        // Set default values
        <span class="cov0" title="0">setDefaults()

        // Read configuration
        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov0" title="0">var config Config
        if err := viper.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// setDefaults sets default configuration values
func setDefaults() <span class="cov0" title="0">{
        // Server defaults
        viper.SetDefault("server.port", 8080)
        viper.SetDefault("server.host", "0.0.0.0")
        viper.SetDefault("server.log_level", "info")

        // Database defaults
        viper.SetDefault("database.path", "data/shelly.db")

        // Discovery defaults
        viper.SetDefault("discovery.enabled", true)
        viper.SetDefault("discovery.networks", []string{"192.168.1.0/24"})
        viper.SetDefault("discovery.interval", 300)
        viper.SetDefault("discovery.timeout", 5)
        viper.SetDefault("discovery.enable_mdns", true)
        viper.SetDefault("discovery.enable_ssdp", true)
        viper.SetDefault("discovery.concurrent_scans", 20)

        // Provisioning defaults
        viper.SetDefault("provisioning.auth_enabled", false)
        viper.SetDefault("provisioning.auth_user", "admin")
        viper.SetDefault("provisioning.cloud_enabled", false)
        viper.SetDefault("provisioning.mqtt_enabled", false)
        viper.SetDefault("provisioning.device_name_pattern", "shelly_{type}_{mac}")
        viper.SetDefault("provisioning.auto_provision", false)
        viper.SetDefault("provisioning.provision_interval", 600)

        // DHCP defaults
        viper.SetDefault("dhcp.network", "192.168.1.0/24")
        viper.SetDefault("dhcp.start_ip", "192.168.1.100")
        viper.SetDefault("dhcp.end_ip", "192.168.1.199")
        viper.SetDefault("dhcp.auto_reserve", false)

        // OPNSense defaults
        viper.SetDefault("opnsense.enabled", false)
        viper.SetDefault("opnsense.port", 443)
        viper.SetDefault("opnsense.auto_apply", false)

        // Main app defaults
        viper.SetDefault("main_app.url", "http://localhost:8080")
        viper.SetDefault("main_app.enabled", true)
}</pre>
		
		<pre class="file" id="file4" style="display: none">package database

import (
        "fmt"

        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
)

// Manager handles database operations for Shelly devices
type Manager struct {
        DB *gorm.DB
}

// NewManager creates a new database manager
func NewManager(dbPath string) (*Manager, error) <span class="cov8" title="1">{
        db, err := gorm.Open(sqlite.Open(dbPath), &amp;gorm.Config{})
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        // Auto-migrate the schema
        <span class="cov8" title="1">if err := db.AutoMigrate(&amp;Device{}); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to migrate database: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;Manager{DB: db}, nil</span>
}

// AddDevice adds a new device to the database
func (m *Manager) AddDevice(device *Device) error <span class="cov8" title="1">{
        return m.DB.Create(device).Error
}</span>

// GetDevices retrieves all devices from the database
func (m *Manager) GetDevices() ([]Device, error) <span class="cov8" title="1">{
        var devices []Device
        err := m.DB.Find(&amp;devices).Error
        return devices, err
}</span>

// GetDevice retrieves a specific device by ID
func (m *Manager) GetDevice(id uint) (*Device, error) <span class="cov8" title="1">{
        var device Device
        err := m.DB.First(&amp;device, id).Error
        return &amp;device, err
}</span>

// UpdateDevice updates an existing device
func (m *Manager) UpdateDevice(device *Device) error <span class="cov8" title="1">{
        return m.DB.Save(device).Error
}</span>

// DeleteDevice removes a device from the database
func (m *Manager) DeleteDevice(id uint) error <span class="cov8" title="1">{
        return m.DB.Delete(&amp;Device{}, id).Error
}</span>

// GetDeviceByMAC retrieves a device by MAC address
func (m *Manager) GetDeviceByMAC(mac string) (*Device, error) <span class="cov8" title="1">{
        var device Device
        err := m.DB.Where("mac = ?", mac).First(&amp;device).Error
        return &amp;device, err
}</pre>
		
		<pre class="file" id="file5" style="display: none">package discovery

import (
        "context"
        "encoding/json"
        "fmt"
        "net"
        "net/http"
        "strings"
        "sync"
        "time"
)

// ShellyDevice represents a discovered Shelly device
type ShellyDevice struct {
        // Gen2+ fields
        ID         string `json:"id"`
        Model      string `json:"model"`
        Generation int    `json:"gen"`
        FirmwareID string `json:"fw_id"`
        Version    string `json:"ver"`
        App        string `json:"app"`
        AuthDomain string `json:"auth_domain"`
        
        // Gen1 fields
        Type       string `json:"type"`
        FW         string `json:"fw"`
        Auth       bool   `json:"auth"`
        
        // Common fields
        MAC        string `json:"mac"`
        AuthEn     bool   `json:"auth_en"`
        
        // Internal fields
        IP         string `json:"-"`
        Discovered time.Time `json:"-"`
}

// Scanner handles device discovery operations
type Scanner struct {
        timeout         time.Duration
        concurrentScans int
        httpClient      *http.Client
}

// NewScanner creates a new discovery scanner
func NewScanner(timeout time.Duration, concurrentScans int) *Scanner <span class="cov8" title="1">{
        if concurrentScans &lt;= 0 </span><span class="cov8" title="1">{
                concurrentScans = 10
        }</span>
        <span class="cov8" title="1">if timeout &lt;= 0 </span><span class="cov8" title="1">{
                timeout = 1 * time.Second  // Reduced timeout for faster scanning
        }</span>

        <span class="cov8" title="1">return &amp;Scanner{
                timeout:         timeout,
                concurrentScans: concurrentScans,
                httpClient: &amp;http.Client{
                        Timeout: timeout,
                },
        }</span>
}

// ScanNetwork performs HTTP-based discovery on the specified network range
func (s *Scanner) ScanNetwork(ctx context.Context, cidr string) ([]ShellyDevice, error) <span class="cov8" title="1">{
        ip, ipnet, err := net.ParseCIDR(cidr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid CIDR: %w", err)
        }</span>

        <span class="cov8" title="1">var devices []ShellyDevice
        var mu sync.Mutex
        var wg sync.WaitGroup
        var scanned, found int32

        // Create a channel for IPs to scan
        ipChan := make(chan string, 100)
        
        // Start worker goroutines
        for i := 0; i &lt; s.concurrentScans; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(workerID int) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        for ip := range ipChan </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                default:<span class="cov8" title="1">
                                        if device := s.checkDevice(ctx, ip); device != nil </span><span class="cov0" title="0">{
                                                mu.Lock()
                                                devices = append(devices, *device)
                                                mu.Unlock()
                                                found++
                                                fmt.Printf("Found Shelly device at %s: %s\n", device.IP, device.Model)
                                        }</span>
                                        <span class="cov8" title="1">scanned++
                                        if scanned%50 == 0 </span><span class="cov0" title="0">{
                                                fmt.Printf("Scanned %d IPs, found %d devices...\n", scanned, found)
                                        }</span>
                                }
                        }
                }(i)
        }

        // Generate IPs to scan
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer close(ipChan)
                for ip := ip.Mask(ipnet.Mask); ipnet.Contains(ip); inc(ip) </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case ipChan &lt;- ip.String():<span class="cov8" title="1"></span>
                        }
                }
        }()

        <span class="cov8" title="1">wg.Wait()
        fmt.Printf("Scan complete: checked %d IPs, found %d devices\n", scanned, found)
        return devices, nil</span>
}

// ScanHost checks a specific host for Shelly device
func (s *Scanner) ScanHost(ctx context.Context, host string) (*ShellyDevice, error) <span class="cov8" title="1">{
        return s.checkDevice(ctx, host), nil
}</span>

// checkDevice attempts to identify a Shelly device at the given IP
func (s *Scanner) checkDevice(ctx context.Context, ip string) *ShellyDevice <span class="cov8" title="1">{
        url := fmt.Sprintf("http://%s/shelly", ip)
        
        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var device ShellyDevice
        if err := json.NewDecoder(resp.Body).Decode(&amp;device); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Validate it's a Shelly device (Gen1 has Type, Gen2+ has ID)
        <span class="cov8" title="1">if device.Type == "" &amp;&amp; device.ID == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Normalize fields for Gen1 devices
        <span class="cov8" title="1">if device.Type != "" &amp;&amp; device.ID == "" </span><span class="cov8" title="1">{
                // Gen1 device
                device.ID = fmt.Sprintf("shelly%s-%s", strings.ToLower(device.Type), device.MAC)
                device.Model = device.Type
                device.Generation = 1
                device.Version = device.FW
                device.AuthEn = device.Auth
        }</span>
        
        // Ensure we have a model field
        <span class="cov8" title="1">if device.Model == "" &amp;&amp; device.Type != "" </span><span class="cov0" title="0">{
                device.Model = device.Type
        }</span>

        <span class="cov8" title="1">device.IP = ip
        device.Discovered = time.Now()
        
        return &amp;device</span>
}

// GetDeviceStatus retrieves the current status of a Shelly device
func (s *Scanner) GetDeviceStatus(ctx context.Context, ip string, gen int) (map[string]interface{}, error) <span class="cov8" title="1">{
        var url string
        if gen == 1 </span><span class="cov8" title="1">{
                url = fmt.Sprintf("http://%s/status", ip)
        }</span> else<span class="cov0" title="0"> {
                // Gen2+ uses RPC-style endpoints
                url = fmt.Sprintf("http://%s/rpc/Shelly.GetStatus", ip)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("status code: %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">var status map[string]interface{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;status); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return status, nil</span>
}

// inc increments an IP address
func inc(ip net.IP) <span class="cov8" title="1">{
        for j := len(ip) - 1; j &gt;= 0; j-- </span><span class="cov8" title="1">{
                ip[j]++
                if ip[j] &gt; 0 </span><span class="cov8" title="1">{
                        break</span>
                }
        }
}

// GetDeviceType returns a human-readable device type based on the model
func GetDeviceType(model string) string <span class="cov8" title="1">{
        model = strings.ToUpper(model)
        
        // Exact model matches for Gen1 devices
        switch model </span>{
        case "SHPLG-S", "SHPLG-1":<span class="cov8" title="1">
                return "Smart Plug"</span>
        case "SHSW-1":<span class="cov8" title="1">
                return "Relay Switch"</span>
        case "SHSW-PM":<span class="cov8" title="1">
                return "Power Meter Switch"</span>
        case "SHSW-25":<span class="cov8" title="1">
                return "Dual Relay/Roller"</span>
        case "SHIX3-1":<span class="cov8" title="1">
                return "3-Input Controller"</span>
        case "SHBTN-1", "SHBTN-2":<span class="cov0" title="0">
                return "Button Controller"</span>
        case "SHDM-1", "SHDM-2":<span class="cov8" title="1">
                return "Dimmer"</span>
        case "SHRGBW2":<span class="cov8" title="1">
                return "RGBW Controller"</span>
        case "SHBLB-1":<span class="cov0" title="0">
                return "Smart Bulb"</span>
        case "SHEM", "SHEM-3":<span class="cov8" title="1">
                return "Energy Meter"</span>
        case "SHUNI-1":<span class="cov8" title="1">
                return "Universal Module"</span>
        case "SHHT-1":<span class="cov8" title="1">
                return "Humidity/Temperature"</span>
        case "SHMOS-01":<span class="cov0" title="0">
                return "Motion Sensor"</span>
        case "SHDW-1", "SHDW-2":<span class="cov0" title="0">
                return "Door/Window Sensor"</span>
        case "SHWT-1":<span class="cov0" title="0">
                return "Flood Sensor"</span>
        case "SHGS-1":<span class="cov0" title="0">
                return "Gas Sensor"</span>
        case "SHSM-01":<span class="cov0" title="0">
                return "Smoke Detector"</span>
        case "SHTRV-01":<span class="cov0" title="0">
                return "TRV Controller"</span>
        }
        
        // Check for Gen2+ models (contain pattern like SNSN-, SPSW-, etc.)
        <span class="cov8" title="1">if strings.HasPrefix(model, "SNSN-") </span><span class="cov8" title="1">{
                return "Plus Sensor"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(model, "SPSW-") </span><span class="cov8" title="1">{
                return "Plus Switch"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(model, "SPSH-") </span><span class="cov0" title="0">{
                return "Plus Smart Home"
        }</span>
        
        // Fallback to pattern matching (order matters - more specific patterns first)
        <span class="cov8" title="1">lowerModel := strings.ToLower(model)
        switch </span>{
        case strings.Contains(lowerModel, "plug"):<span class="cov8" title="1">
                return "Smart Plug"</span>
        case strings.Contains(lowerModel, "valve"):<span class="cov8" title="1">
                return "Valve Controller"</span>
        case strings.Contains(lowerModel, "i3"):<span class="cov8" title="1">
                return "3-Input Controller"</span>
        case strings.Contains(lowerModel, "uni"):<span class="cov8" title="1">
                return "Universal Module"</span>
        case strings.Contains(lowerModel, "roller") || strings.Contains(lowerModel, "shutter"):<span class="cov8" title="1">
                return "Roller Shutter"</span>
        case strings.Contains(lowerModel, "pm"):<span class="cov8" title="1">
                return "Power Meter Device"</span>
        case strings.Contains(lowerModel, "dimmer"):<span class="cov8" title="1">
                return "Dimmer"</span>
        case strings.Contains(lowerModel, "rgbw"):<span class="cov8" title="1">
                return "RGBW Light"</span>
        case strings.Contains(lowerModel, "bulb"):<span class="cov8" title="1">
                return "Smart Bulb"</span>
        case strings.Contains(lowerModel, "motion"):<span class="cov8" title="1">
                return "Motion Sensor"</span>
        case strings.Contains(lowerModel, "ht"):<span class="cov8" title="1">
                return "Humidity/Temperature"</span>
        case strings.Contains(lowerModel, "flood"):<span class="cov8" title="1">
                return "Flood Sensor"</span>
        case strings.Contains(lowerModel, "door") || strings.Contains(lowerModel, "window"):<span class="cov8" title="1">
                return "Door/Window Sensor"</span>
        case strings.Contains(lowerModel, "smoke"):<span class="cov8" title="1">
                return "Smoke Detector"</span>
        case strings.Contains(lowerModel, "gas"):<span class="cov8" title="1">
                return "Gas Detector"</span>
        case strings.Contains(lowerModel, "em"):<span class="cov8" title="1">
                return "Energy Meter"</span>
        case strings.Contains(lowerModel, "button"):<span class="cov8" title="1">
                return "Button Controller"</span>
        case strings.Contains(lowerModel, "plus"):<span class="cov8" title="1">
                return "Plus Device"</span>
        case strings.Contains(lowerModel, "pro"):<span class="cov8" title="1">
                return "Pro Device"</span>
        default:<span class="cov8" title="1">
                return "Shelly Device"</span>
        }
}</pre>
		
		<pre class="file" id="file6" style="display: none">package discovery

import (
        "context"
        "fmt"
        "net"
        "strings"
        "time"

        "github.com/hashicorp/mdns"
)

// MDNSScanner handles mDNS-based device discovery
type MDNSScanner struct {
        timeout time.Duration
        scanner *Scanner
}

// NewMDNSScanner creates a new mDNS scanner
func NewMDNSScanner(timeout time.Duration) *MDNSScanner <span class="cov0" title="0">{
        if timeout &lt;= 0 </span><span class="cov0" title="0">{
                timeout = 5 * time.Second
        }</span>
        
        <span class="cov0" title="0">return &amp;MDNSScanner{
                timeout: timeout,
                scanner: NewScanner(2*time.Second, 5),
        }</span>
}

// DiscoverDevices discovers Shelly devices using mDNS
func (m *MDNSScanner) DiscoverDevices(ctx context.Context) ([]ShellyDevice, error) <span class="cov0" title="0">{
        var devices []ShellyDevice
        entriesCh := make(chan *mdns.ServiceEntry, 10)
        
        // Start the discovery
        go func() </span><span class="cov0" title="0">{
                defer close(entriesCh)
                
                // Look for Shelly-specific service
                params := mdns.DefaultParams("_shelly._tcp")
                params.Entries = entriesCh
                params.Timeout = m.timeout
                params.DisableIPv6 = true
                
                if err := mdns.Query(params); err != nil </span><span class="cov0" title="0">{
                        // Try generic HTTP service as fallback
                        params.Service = "_http._tcp"
                        mdns.Query(params)
                }</span>
        }()
        
        // Process discovered services
        <span class="cov0" title="0">seen := make(map[string]bool)
        for entry := range entriesCh </span><span class="cov0" title="0">{
                // Check if it's a Shelly device
                if !m.isShellyDevice(entry) </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Get the best IP address
                <span class="cov0" title="0">ip := m.getBestIP(entry)
                if ip == "" || seen[ip] </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">seen[ip] = true
                
                // Verify it's actually a Shelly device by querying the API
                device := m.scanner.checkDevice(ctx, ip)
                if device != nil </span><span class="cov0" title="0">{
                        devices = append(devices, *device)
                }</span>
        }
        
        <span class="cov0" title="0">return devices, nil</span>
}

// isShellyDevice checks if an mDNS entry is likely a Shelly device
func (m *MDNSScanner) isShellyDevice(entry *mdns.ServiceEntry) bool <span class="cov0" title="0">{
        // Check service name
        if strings.Contains(strings.ToLower(entry.Name), "shelly") </span><span class="cov0" title="0">{
                return true
        }</span>
        
        // Check hostname
        <span class="cov0" title="0">if strings.Contains(strings.ToLower(entry.Host), "shelly") </span><span class="cov0" title="0">{
                return true
        }</span>
        
        // Check TXT records for Shelly-specific info
        <span class="cov0" title="0">for _, txt := range entry.InfoFields </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(txt), "shelly") ||
                   strings.Contains(txt, "gen=") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

// getBestIP returns the best IP address from an mDNS entry
func (m *MDNSScanner) getBestIP(entry *mdns.ServiceEntry) string <span class="cov0" title="0">{
        // Prefer IPv4 addresses
        if entry.AddrV4 != nil </span><span class="cov0" title="0">{
                return entry.AddrV4.String()
        }</span>
        
        // Fall back to IPv6 if available
        <span class="cov0" title="0">if entry.AddrV6 != nil </span><span class="cov0" title="0">{
                // Check if it's a link-local address and skip if so
                if !entry.AddrV6.IsLinkLocalUnicast() </span><span class="cov0" title="0">{
                        return entry.AddrV6.String()
                }</span>
        }
        
        // Try to resolve hostname if no direct IP
        <span class="cov0" title="0">if entry.Host != "" </span><span class="cov0" title="0">{
                if ips, err := net.LookupIP(entry.Host); err == nil </span><span class="cov0" title="0">{
                        for _, ip := range ips </span><span class="cov0" title="0">{
                                if ip4 := ip.To4(); ip4 != nil </span><span class="cov0" title="0">{
                                        return ip4.String()
                                }</span>
                        }
                }
        }
        
        <span class="cov0" title="0">return ""</span>
}

// CombinedDiscovery performs both HTTP scanning and mDNS discovery
func CombinedDiscovery(ctx context.Context, networks []string, timeout time.Duration) ([]ShellyDevice, error) <span class="cov0" title="0">{
        var allDevices []ShellyDevice
        seen := make(map[string]bool)
        
        // HTTP scanning for specified networks
        if len(networks) &gt; 0 </span><span class="cov0" title="0">{
                scanner := NewScanner(timeout, 50)  // Increased concurrency for faster scanning
                for _, network := range networks </span><span class="cov0" title="0">{
                        devices, err := scanner.ScanNetwork(ctx, network)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error scanning network %s: %v\n", network, err)
                                continue</span>
                        }
                        
                        <span class="cov0" title="0">for _, device := range devices </span><span class="cov0" title="0">{
                                if !seen[device.MAC] </span><span class="cov0" title="0">{
                                        allDevices = append(allDevices, device)
                                        seen[device.MAC] = true
                                }</span>
                        }
                }
        }
        
        // mDNS discovery
        <span class="cov0" title="0">mdnsScanner := NewMDNSScanner(timeout)
        mdnsDevices, err := mdnsScanner.DiscoverDevices(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("mDNS discovery error: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                for _, device := range mdnsDevices </span><span class="cov0" title="0">{
                        if !seen[device.MAC] </span><span class="cov0" title="0">{
                                allDevices = append(allDevices, device)
                                seen[device.MAC] = true
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return allDevices, nil</span>
}</pre>
		
		<pre class="file" id="file7" style="display: none">package service

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/ginsys/shelly-manager/internal/config"
        "github.com/ginsys/shelly-manager/internal/database"
        "github.com/ginsys/shelly-manager/internal/discovery"
)

// ShellyService handles the core business logic
type ShellyService struct {
        DB     *database.Manager
        Config *config.Config
        ctx    context.Context
        cancel context.CancelFunc
}

// NewService creates a new Shelly service
func NewService(db *database.Manager, cfg *config.Config) *ShellyService <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        
        return &amp;ShellyService{
                DB:     db,
                Config: cfg,
                ctx:    ctx,
                cancel: cancel,
        }
}</span>

// DiscoverDevices performs device discovery using HTTP and mDNS
func (s *ShellyService) DiscoverDevices(network string) ([]database.Device, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        log.Printf("Starting device discovery on network: %s", network)
        
        // Determine networks to scan
        var networks []string
        if network != "" &amp;&amp; network != "auto" </span><span class="cov0" title="0">{
                networks = []string{network}
        }</span> else<span class="cov0" title="0"> if len(s.Config.Discovery.Networks) &gt; 0 </span><span class="cov0" title="0">{
                networks = s.Config.Discovery.Networks
        }</span>
        
        // Use timeout from config or default
        <span class="cov0" title="0">timeout := time.Duration(s.Config.Discovery.Timeout) * time.Second
        if timeout &lt;= 0 </span><span class="cov0" title="0">{
                timeout = 2 * time.Second
        }</span>
        
        // Perform combined discovery (HTTP + mDNS)
        <span class="cov0" title="0">shellyDevices, err := discovery.CombinedDiscovery(ctx, networks, timeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("discovery failed: %w", err)
        }</span>
        
        // Convert discovered Shelly devices to our Device model
        <span class="cov0" title="0">var devices []database.Device
        for _, sd := range shellyDevices </span><span class="cov0" title="0">{
                device := database.Device{
                        IP:       sd.IP,
                        MAC:      sd.MAC,
                        Type:     discovery.GetDeviceType(sd.Model),
                        Name:     sd.ID, // Use ID as initial name, can be updated later
                        Firmware: sd.Version,
                        Status:   "online",
                        LastSeen: sd.Discovered,
                        Settings: fmt.Sprintf(`{"model":"%s","gen":%d,"auth_enabled":%v}`, 
                                sd.Model, sd.Generation, sd.AuthEn),
                }
                devices = append(devices, device)
        }</span>
        
        <span class="cov0" title="0">log.Printf("Discovery complete. Found %d devices", len(devices))
        return devices, nil</span>
}

// Stop gracefully stops the service
func (s *ShellyService) Stop() <span class="cov0" title="0">{
        s.cancel()
}</pre>
		
		<pre class="file" id="file8" style="display: none">package testutil

import (
        "encoding/json"
        "net/http"
        "net/http/httptest"
        "os"
        "path/filepath"
        "testing"
        "time"

        "github.com/ginsys/shelly-manager/internal/config"
        "github.com/ginsys/shelly-manager/internal/database"
)

// TestConfig creates a test configuration
func TestConfig() *config.Config <span class="cov0" title="0">{
        return &amp;config.Config{
                Server: struct {
                        Port     int    `mapstructure:"port"`
                        Host     string `mapstructure:"host"`
                        LogLevel string `mapstructure:"log_level"`
                }{
                        Port:     8080,
                        Host:     "127.0.0.1",
                        LogLevel: "debug",
                },
                Database: struct {
                        Path string `mapstructure:"path"`
                }{
                        Path: ":memory:", // Use in-memory SQLite for tests
                },
                Discovery: struct {
                        Enabled          bool     `mapstructure:"enabled"`
                        Networks         []string `mapstructure:"networks"`
                        Interval         int      `mapstructure:"interval"`
                        Timeout          int      `mapstructure:"timeout"`
                        EnableMDNS       bool     `mapstructure:"enable_mdns"`
                        EnableSSDP       bool     `mapstructure:"enable_ssdp"`
                        ConcurrentScans  int      `mapstructure:"concurrent_scans"`
                }{
                        Enabled:         true,
                        Networks:        []string{"192.168.1.0/24"},
                        Interval:        300,
                        Timeout:         2,
                        EnableMDNS:      true,
                        EnableSSDP:      true,
                        ConcurrentScans: 10,
                },
        }
}</span>

// TestDatabase creates a test database manager
func TestDatabase(t *testing.T) *database.Manager <span class="cov0" title="0">{
        db, err := database.NewManager(":memory:")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test database: %v", err)
        }</span>
        <span class="cov0" title="0">return db</span>
}

// TestDevice creates a test device
func TestDevice() *database.Device <span class="cov0" title="0">{
        return &amp;database.Device{
                IP:       "192.168.1.100",
                MAC:      "A4:CF:12:34:56:78",
                Type:     "Smart Plug",
                Name:     "Test Device",
                Firmware: "20231219-134356",
                Status:   "online",
                LastSeen: time.Now(),
                Settings: `{"model":"SHPLG-S","gen":1,"auth_enabled":true}`,
        }
}</span>

// MockShellyServer creates a mock HTTP server that simulates Shelly device responses
func MockShellyServer() *httptest.Server <span class="cov0" title="0">{
        mux := http.NewServeMux()
        
        // Mock Gen1 device responses
        mux.HandleFunc("/shelly", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                response := map[string]interface{}{
                        "type":         "SHPLG-S",
                        "mac":          "A4CF12345678",
                        "auth":         true,
                        "fw":           "20231219-134356",
                        "discoverable": true,
                        "num_outputs":  1,
                        "num_meters":   1,
                }
                json.NewEncoder(w).Encode(response)
        }</span>)
        
        // Mock status endpoint
        <span class="cov0" title="0">mux.HandleFunc("/status", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                response := map[string]interface{}{
                        "wifi_sta": map[string]interface{}{
                                "connected": true,
                                "ssid":      "TestNetwork",
                                "ip":        "192.168.1.100",
                                "rssi":      -45,
                        },
                        "cloud": map[string]interface{}{
                                "enabled":   false,
                                "connected": false,
                        },
                        "mqtt": map[string]interface{}{
                                "connected": false,
                        },
                        "time":       time.Now().Format("15:04"),
                        "unixtime":   time.Now().Unix(),
                        "serial":     12345,
                        "has_update": false,
                        "mac":        "A4CF12345678",
                        "cfg_changed_cnt": 2,
                        "actions_stats": map[string]interface{}{
                                "skipped": 0,
                        },
                        "relays": []map[string]interface{}{
                                {
                                        "ison":           true,
                                        "has_timer":      false,
                                        "timer_started":  0,
                                        "timer_duration": 0,
                                        "timer_remaining": 0,
                                        "overpower":      false,
                                        "overtemperature": false,
                                        "is_valid":       true,
                                        "source":         "input",
                                },
                        },
                        "meters": []map[string]interface{}{
                                {
                                        "power":     25.5,
                                        "overpower": 0.0,
                                        "is_valid":  true,
                                        "timestamp": time.Now().Unix(),
                                        "counters":  []float64{123.456, 234.567, 345.678},
                                        "total":     703.501,
                                },
                        },
                        "temperature": 45.2,
                        "overtemperature": false,
                        "tmp": map[string]interface{}{
                                "tC":       45.2,
                                "tF":       113.36,
                                "is_valid": true,
                        },
                        "ram_total": 50592,
                        "ram_free":  39052,
                        "fs_size":   233681,
                        "fs_free":   162648,
                        "uptime":    3600,
                }
                json.NewEncoder(w).Encode(response)
        }</span>)
        
        <span class="cov0" title="0">return httptest.NewServer(mux)</span>
}

// MockShellyGen2Server creates a mock server for Gen2+ devices
func MockShellyGen2Server() *httptest.Server <span class="cov0" title="0">{
        mux := http.NewServeMux()
        
        // Mock Gen2 device responses
        mux.HandleFunc("/shelly", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                response := map[string]interface{}{
                        "id":          "shellyplusht-08b61fcb7f3c",
                        "mac":         "08B61FCB7F3C",
                        "model":       "SNSN-0013A",
                        "gen":         2,
                        "fw_id":       "20231031-165617/1.0.3-geb51a17",
                        "ver":         "1.0.3",
                        "app":         "PlusHT",
                        "auth_en":     false,
                        "auth_domain": "shellyplusht-08b61fcb7f3c",
                }
                json.NewEncoder(w).Encode(response)
        }</span>)
        
        <span class="cov0" title="0">return httptest.NewServer(mux)</span>
}

// TempDir creates a temporary directory for testing
func TempDir(t *testing.T) string <span class="cov0" title="0">{
        dir, err := os.MkdirTemp("", "shelly-manager-test-*")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create temp directory: %v", err)
        }</span>
        
        <span class="cov0" title="0">t.Cleanup(func() </span><span class="cov0" title="0">{
                os.RemoveAll(dir)
        }</span>)
        
        <span class="cov0" title="0">return dir</span>
}

// CreateTestConfigFile creates a temporary config file for testing
func CreateTestConfigFile(t *testing.T, cfg *config.Config) string <span class="cov0" title="0">{
        dir := TempDir(t)
        configFile := filepath.Join(dir, "test-config.yaml")
        
        content := `server:
  port: 8080
  host: "127.0.0.1"
  log_level: "debug"

database:
  path: ":memory:"

discovery:
  enabled: true
  networks:
    - "192.168.1.0/24"
  interval: 300
  timeout: 2
  enable_mdns: true
  enable_ssdp: true
  concurrent_scans: 10
`
        
        if err := os.WriteFile(configFile, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to write test config file: %v", err)
        }</span>
        
        <span class="cov0" title="0">return configFile</span>
}

// AssertNoError fails the test if err is not nil
func AssertNoError(t *testing.T, err error) <span class="cov0" title="0">{
        t.Helper()
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Expected no error, got: %v", err)
        }</span>
}

// AssertError fails the test if err is nil
func AssertError(t *testing.T, err error) <span class="cov0" title="0">{
        t.Helper()
        if err == nil </span><span class="cov0" title="0">{
                t.Fatal("Expected an error, got nil")
        }</span>
}

// AssertEqual fails the test if expected != actual
func AssertEqual[T comparable](t *testing.T, expected, actual T) <span class="cov0" title="0">{
        t.Helper()
        if expected != actual </span><span class="cov0" title="0">{
                t.Fatalf("Expected %v, got %v", expected, actual)
        }</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
