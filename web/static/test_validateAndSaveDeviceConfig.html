<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ValidateAndSaveDeviceConfig Function Tests</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test { margin: 20px 0; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        .pass { background-color: #d4edda; border-color: #28a745; }
        .fail { background-color: #f8d7da; border-color: #dc3545; }
        .pending { background-color: #fff3cd; border-color: #ffc107; }
        .log { background: #f8f9fa; padding: 10px; margin: 10px 0; border-left: 4px solid #007bff; font-family: monospace; white-space: pre-wrap; }
        button { padding: 10px 15px; margin: 5px; cursor: pointer; }
        #mock-server-status { margin: 10px 0; padding: 10px; background: #e9ecef; border-radius: 3px; }
        .field-error, .field-warning { font-size: 12px; margin-top: 4px; }
        .field-error { color: #e74c3c; }
        .field-warning { color: #f39c12; }
        input.error { border-color: #e74c3c; }
        input.warning { border-color: #f39c12; }
        .modal { display: none; }
        #test-form { margin: 20px 0; padding: 20px; border: 1px solid #ddd; border-radius: 5px; background: #f9f9f9; }
        .form-group { margin: 10px 0; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input, select { width: 200px; padding: 5px; margin-bottom: 5px; }
    </style>
</head>
<body>
    <h1>ValidateAndSaveDeviceConfig Function Test Suite</h1>
    <div id="mock-server-status">Mock server status: <span id="server-status">Not started</span></div>
    
    <button onclick="runAllTests()">Run All Tests</button>
    <button onclick="clearResults()">Clear Results</button>
    
    <!-- Test Form for Configuration Collection -->
    <div id="test-form">
        <h3>Test Configuration Form</h3>
        <div class="form-group">
            <label for="wifi-sta-enable">
                <input type="checkbox" id="wifi-sta-enable"> Enable WiFi
            </label>
        </div>
        <div class="form-group">
            <label for="wifi-sta-ssid">WiFi SSID:</label>
            <input type="text" id="wifi-sta-ssid" value="TestNetwork">
        </div>
        <div class="form-group">
            <label for="wifi-sta-password">WiFi Password:</label>
            <input type="password" id="wifi-sta-password" value="testpassword">
        </div>
        <div class="form-group">
            <label for="wifi-sta-ipv4mode">IP Mode:</label>
            <select id="wifi-sta-ipv4mode">
                <option value="dhcp">DHCP</option>
                <option value="static">Static</option>
            </select>
        </div>
        <div class="form-group">
            <label for="mqtt-enable">
                <input type="checkbox" id="mqtt-enable"> Enable MQTT
            </label>
        </div>
        <div class="form-group">
            <label for="mqtt-server">MQTT Server:</label>
            <input type="text" id="mqtt-server" value="broker.example.com:1883">
        </div>
        <div class="form-group">
            <label for="mqtt-user">MQTT User:</label>
            <input type="text" id="mqtt-user" value="mqtt-user">
        </div>
        <div class="form-group">
            <label for="auth-enable">
                <input type="checkbox" id="auth-enable"> Enable Authentication
            </label>
        </div>
        <div class="form-group">
            <label for="auth-user">Auth User:</label>
            <input type="text" id="auth-user" value="admin">
        </div>
        <div class="form-group">
            <label for="auth-password">Auth Password:</label>
            <input type="password" id="auth-password" value="securepass">
        </div>
    </div>
    
    <div id="test-results"></div>
    
    <!-- Mock elements for testing -->
    <div id="save-status"></div>
    <button id="save-config-btn">Save Configuration</button>

    <script>
        // Constants and global variables
        const API_BASE = '/api/v1';
        let testResults = [];
        let mockFormData = {};
        
        // Mock the console to capture logs for testing
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;
        const originalConfirm = window.confirm;
        let testLogs = [];
        let confirmResult = true;
        
        function captureConsole() {
            testLogs = [];
            console.log = (...args) => {
                testLogs.push({ type: 'log', message: args.join(' ') });
                originalConsoleLog(...args);
            };
            console.error = (...args) => {
                testLogs.push({ type: 'error', message: args.join(' ') });
                originalConsoleError(...args);
            };
            window.confirm = (message) => {
                testLogs.push({ type: 'confirm', message: message });
                return confirmResult;
            };
        }
        
        function restoreConsole() {
            console.log = originalConsoleLog;
            console.error = originalConsoleError;
            window.confirm = originalConfirm;
        }
        
        // Mock functions needed by validateAndSaveDeviceConfig
        function clearValidationErrors() {
            document.querySelectorAll('.field-error').forEach(error => error.remove());
            document.querySelectorAll('.field-warning').forEach(warning => warning.remove());
            document.querySelectorAll('input, select').forEach(field => {
                field.classList.remove('error', 'warning');
            });
        }
        
        function displayValidationWarnings(warnings) {
            warnings.forEach(warning => {
                const field = findFormFieldByName(warning.field);
                if (field) {
                    field.classList.add('warning');
                    const warningElement = createFieldMessage(field, 'field-warning');
                    warningElement.textContent = `⚠️ ${warning.message}`;
                }
            });
        }
        
        function displayValidationErrors(errors) {
            errors.forEach(error => {
                const field = findFormFieldByName(error.field);
                if (field) {
                    field.classList.add('error');
                    const errorElement = createFieldMessage(field, 'field-error');
                    errorElement.textContent = `❌ ${error.message}`;
                }
            });
        }
        
        function findFormFieldByName(fieldName) {
            const possibleIds = [
                fieldName,
                fieldName.replace('.', '-'),
                fieldName.replace(/\./g, '-'),
                `${fieldName.split('.')[0]}-${fieldName.split('.').slice(1).join('-')}`
            ];
            
            for (const id of possibleIds) {
                const element = document.getElementById(id);
                if (element) return element;
            }
            
            return document.querySelector(`[name="${fieldName}"]`);
        }
        
        function createFieldMessage(field, className) {
            const messageElement = document.createElement('div');
            messageElement.className = className;
            messageElement.style.color = className.includes('error') ? '#e74c3c' : '#f39c12';
            messageElement.style.fontSize = '12px';
            messageElement.style.marginTop = '4px';
            
            field.parentNode.insertBefore(messageElement, field.nextSibling);
            return messageElement;
        }
        
        function collectFormData() {
            // Use mock data if provided, otherwise collect from form
            if (Object.keys(mockFormData).length > 0) {
                return mockFormData;
            }
            
            const config = {};
            
            // WiFi Configuration
            if (document.getElementById('wifi-sta-enable').checked) {
                config.wifi = {
                    enable: true,
                    ssid: document.getElementById('wifi-sta-ssid').value,
                    password: document.getElementById('wifi-sta-password').value,
                    ipv4mode: document.getElementById('wifi-sta-ipv4mode').value
                };
            }
            
            // MQTT Configuration
            if (document.getElementById('mqtt-enable').checked) {
                config.mqtt = {
                    enable: true,
                    server: document.getElementById('mqtt-server').value,
                    user: document.getElementById('mqtt-user').value
                };
            }
            
            // Auth Configuration
            if (document.getElementById('auth-enable').checked) {
                config.auth = {
                    enable: true,
                    user: document.getElementById('auth-user').value,
                    password: document.getElementById('auth-password').value
                };
            }
            
            return config;
        }
        
        function loadDevices() {
            // Mock implementation
            testLogs.push({ type: 'log', message: 'loadDevices called' });
        }
        
        function closeModal(modalId) {
            testLogs.push({ type: 'log', message: `closeModal called: ${modalId}` });
        }
        
        // Mock fetch function for different test scenarios
        function createMockFetch(validationScenario, saveScenario) {
            return async (url, options) => {
                await new Promise(resolve => setTimeout(resolve, 10)); // Simulate network delay
                
                if (url.includes('/configuration/validate-typed')) {
                    switch (validationScenario) {
                        case 'validation-success':
                            return {
                                ok: true,
                                status: 200,
                                json: async () => ({
                                    valid: true,
                                    errors: [],
                                    warnings: [
                                        { field: 'mqtt.server', message: 'MQTT server not verified', code: 'MQTT_UNVERIFIED' }
                                    ]
                                })
                            };
                        case 'validation-errors':
                            return {
                                ok: true,
                                status: 200,
                                json: async () => ({
                                    valid: false,
                                    errors: [
                                        { field: 'wifi.ssid', message: 'SSID is required', code: 'REQUIRED_FIELD' },
                                        { field: 'auth.password', message: 'Password is required when auth is enabled', code: 'REQUIRED_PASSWORD' }
                                    ],
                                    warnings: []
                                })
                            };
                        case 'validation-server-error':
                            return {
                                ok: false,
                                status: 500,
                                statusText: 'Internal Server Error',
                                text: async () => 'Validation service unavailable'
                            };
                        case 'validation-network-error':
                            throw new Error('Network error during validation');
                    }
                }
                
                if (url.includes('/config/typed')) {
                    switch (saveScenario) {
                        case 'save-success':
                            return {
                                ok: true,
                                status: 200,
                                json: async () => ({
                                    success: true,
                                    message: 'Configuration saved successfully'
                                })
                            };
                        case 'save-server-error':
                            return {
                                ok: false,
                                status: 500,
                                statusText: 'Internal Server Error',
                                text: async () => 'Failed to save configuration'
                            };
                        case 'save-not-found':
                            return {
                                ok: false,
                                status: 404,
                                statusText: 'Not Found',
                                text: async () => 'Device not found'
                            };
                        case 'save-network-error':
                            throw new Error('Network error during save');
                    }
                }
                
                return {
                    ok: false,
                    status: 500,
                    statusText: 'Mock error'
                };
            };
        }
        
        // Include the validateAndSaveDeviceConfig function from the main HTML file
        ${getValidateAndSaveDeviceConfigFunction()}
        
        // Test cases
        const tests = [
            {
                name: 'validateAndSaveDeviceConfig - No device ID error',
                test: async () => {
                    window.currentEditDeviceId = null;
                    window.fetch = createMockFetch('validation-success', 'save-success');
                    captureConsole();
                    
                    await validateAndSaveDeviceConfig();
                    
                    restoreConsole();
                    
                    const statusElement = document.getElementById('save-status');
                    
                    return [
                        { condition: statusElement.textContent === 'Error: No device selected for saving', message: 'Should show no device error' },
                        { condition: statusElement.className === 'error', message: 'Should have error class' }
                    ];
                }
            },
            
            {
                name: 'validateAndSaveDeviceConfig - Successful validation and save',
                test: async () => {
                    window.currentEditDeviceId = 1;
                    window.fetch = createMockFetch('validation-success', 'save-success');
                    mockFormData = {
                        wifi: { enable: true, ssid: 'TestNetwork', password: 'pass123' },
                        mqtt: { enable: true, server: 'broker.example.com:1883' }
                    };
                    confirmResult = true;
                    captureConsole();
                    
                    await validateAndSaveDeviceConfig();
                    
                    restoreConsole();
                    mockFormData = {};
                    
                    const statusElement = document.getElementById('save-status');
                    const saveButton = document.getElementById('save-config-btn');
                    
                    return [
                        { condition: statusElement.textContent.includes('Configuration saved successfully'), message: 'Should show success message' },
                        { condition: statusElement.textContent.includes('(1 warning'), message: 'Should show warning count' },
                        { condition: statusElement.className === 'success', message: 'Should have success class' },
                        { condition: saveButton.textContent === 'Save Configuration', message: 'Button text should be restored' },
                        { condition: !saveButton.disabled, message: 'Button should be re-enabled' },
                        { condition: testLogs.some(log => log.message.includes('loadDevices called')), message: 'Should refresh device list' },
                        { condition: testLogs.some(log => log.type === 'confirm'), message: 'Should show auto-close confirmation' }
                    ];
                }
            },
            
            {
                name: 'validateAndSaveDeviceConfig - Validation errors block save',
                test: async () => {
                    window.currentEditDeviceId = 1;
                    window.fetch = createMockFetch('validation-errors', 'save-success');
                    mockFormData = {
                        wifi: { enable: true, ssid: '' }, // Empty SSID will cause validation error
                        auth: { enable: true, user: 'admin' } // Missing password
                    };
                    captureConsole();
                    
                    await validateAndSaveDeviceConfig();
                    
                    restoreConsole();
                    mockFormData = {};
                    
                    const statusElement = document.getElementById('save-status');
                    const saveButton = document.getElementById('save-config-btn');
                    
                    return [
                        { condition: statusElement.textContent.includes('Validation failed: 2 error(s) found'), message: 'Should show validation error count' },
                        { condition: statusElement.className === 'error', message: 'Should have error class' },
                        { condition: saveButton.textContent === 'Save Configuration', message: 'Button text should be restored' },
                        { condition: !saveButton.disabled, message: 'Button should be re-enabled' },
                        { condition: !testLogs.some(log => log.message.includes('loadDevices called')), message: 'Should NOT refresh device list on validation failure' },
                        { condition: document.querySelectorAll('.field-error').length > 0, message: 'Should display field-level errors' }
                    ];
                }
            },
            
            {
                name: 'validateAndSaveDeviceConfig - Validation server error',
                test: async () => {
                    window.currentEditDeviceId = 1;
                    window.fetch = createMockFetch('validation-server-error', 'save-success');
                    mockFormData = { wifi: { enable: true, ssid: 'TestNetwork' } };
                    captureConsole();
                    
                    await validateAndSaveDeviceConfig();
                    
                    restoreConsole();
                    mockFormData = {};
                    
                    const statusElement = document.getElementById('save-status');
                    
                    return [
                        { condition: statusElement.textContent.includes('Validation request failed (500)'), message: 'Should show validation server error' },
                        { condition: statusElement.textContent.includes('Validation service unavailable'), message: 'Should show error details' },
                        { condition: statusElement.className === 'error', message: 'Should have error class' }
                    ];
                }
            },
            
            {
                name: 'validateAndSaveDeviceConfig - Save server error',
                test: async () => {
                    window.currentEditDeviceId = 1;
                    window.fetch = createMockFetch('validation-success', 'save-server-error');
                    mockFormData = { wifi: { enable: true, ssid: 'TestNetwork' } };
                    captureConsole();
                    
                    await validateAndSaveDeviceConfig();
                    
                    restoreConsole();
                    mockFormData = {};
                    
                    const statusElement = document.getElementById('save-status');
                    
                    return [
                        { condition: statusElement.textContent.includes('Save failed (500)'), message: 'Should show save server error' },
                        { condition: statusElement.textContent.includes('Failed to save configuration'), message: 'Should show error details' },
                        { condition: statusElement.className === 'error', message: 'Should have error class' }
                    ];
                }
            },
            
            {
                name: 'validateAndSaveDeviceConfig - Device not found during save',
                test: async () => {
                    window.currentEditDeviceId = 999;
                    window.fetch = createMockFetch('validation-success', 'save-not-found');
                    mockFormData = { wifi: { enable: true, ssid: 'TestNetwork' } };
                    captureConsole();
                    
                    await validateAndSaveDeviceConfig();
                    
                    restoreConsole();
                    mockFormData = {};
                    
                    const statusElement = document.getElementById('save-status');
                    
                    return [
                        { condition: statusElement.textContent.includes('Save failed (404)'), message: 'Should show 404 error' },
                        { condition: statusElement.textContent.includes('Device not found'), message: 'Should show not found details' },
                        { condition: statusElement.className === 'error', message: 'Should have error class' }
                    ];
                }
            },
            
            {
                name: 'validateAndSaveDeviceConfig - Network errors during validation',
                test: async () => {
                    window.currentEditDeviceId = 1;
                    window.fetch = createMockFetch('validation-network-error', 'save-success');
                    mockFormData = { wifi: { enable: true, ssid: 'TestNetwork' } };
                    captureConsole();
                    
                    await validateAndSaveDeviceConfig();
                    
                    restoreConsole();
                    mockFormData = {};
                    
                    const statusElement = document.getElementById('save-status');
                    
                    return [
                        { condition: statusElement.textContent.includes('Network error during validation'), message: 'Should show network error' },
                        { condition: statusElement.className === 'error', message: 'Should have error class' }
                    ];
                }
            },
            
            {
                name: 'validateAndSaveDeviceConfig - Network errors during save',
                test: async () => {
                    window.currentEditDeviceId = 1;
                    window.fetch = createMockFetch('validation-success', 'save-network-error');
                    mockFormData = { wifi: { enable: true, ssid: 'TestNetwork' } };
                    captureConsole();
                    
                    await validateAndSaveDeviceConfig();
                    
                    restoreConsole();
                    mockFormData = {};
                    
                    const statusElement = document.getElementById('save-status');
                    
                    return [
                        { condition: statusElement.textContent.includes('Network error during save'), message: 'Should show network error during save' },
                        { condition: statusElement.className === 'error', message: 'Should have error class' }
                    ];
                }
            },
            
            {
                name: 'validateAndSaveDeviceConfig - Button states during process',
                test: async () => {
                    window.currentEditDeviceId = 1;
                    
                    // Create a delayed mock to test button states
                    window.fetch = async (url, options) => {
                        const button = document.getElementById('save-config-btn');
                        const status = document.getElementById('save-status');
                        
                        if (url.includes('/configuration/validate-typed')) {
                            // Check button state during validation
                            const validatingState = button.textContent === 'Validating...' && button.disabled;
                            const statusValidating = status.textContent === 'Validating configuration...';
                            
                            await new Promise(resolve => setTimeout(resolve, 50));
                            return {
                                ok: true,
                                status: 200,
                                json: async () => ({ valid: true, errors: [], warnings: [] })
                            };
                        }
                        
                        if (url.includes('/config/typed')) {
                            // Check button state during save
                            const savingState = button.textContent === 'Saving...' && button.disabled;
                            
                            await new Promise(resolve => setTimeout(resolve, 50));
                            return {
                                ok: true,
                                status: 200,
                                json: async () => ({ success: true })
                            };
                        }
                        
                        return { ok: false, status: 500 };
                    };
                    
                    mockFormData = { wifi: { enable: true, ssid: 'TestNetwork' } };
                    confirmResult = false; // Don't auto-close modal
                    captureConsole();
                    
                    await validateAndSaveDeviceConfig();
                    
                    restoreConsole();
                    mockFormData = {};
                    
                    const saveButton = document.getElementById('save-config-btn');
                    
                    return [
                        { condition: saveButton.textContent === 'Save Configuration', message: 'Button text should be restored after completion' },
                        { condition: !saveButton.disabled, message: 'Button should be enabled after completion' }
                    ];
                }
            },
            
            {
                name: 'validateAndSaveDeviceConfig - Field-level validation display',
                test: async () => {
                    window.currentEditDeviceId = 1;
                    window.fetch = createMockFetch('validation-errors', 'save-success');
                    
                    // Set up form with testable fields
                    document.getElementById('wifi-sta-ssid').value = '';
                    document.getElementById('auth-enable').checked = true;
                    document.getElementById('auth-password').value = '';
                    
                    mockFormData = {
                        wifi: { enable: true, ssid: '' },
                        auth: { enable: true, user: 'admin', password: '' }
                    };
                    
                    captureConsole();
                    
                    await validateAndSaveDeviceConfig();
                    
                    restoreConsole();
                    mockFormData = {};
                    
                    // Check for field-level error display
                    const wifiField = document.getElementById('wifi-sta-ssid');
                    const authField = document.getElementById('auth-password');
                    
                    return [
                        { condition: wifiField.classList.contains('error'), message: 'WiFi SSID field should have error class' },
                        { condition: authField.classList.contains('error'), message: 'Auth password field should have error class' },
                        { condition: document.querySelectorAll('.field-error').length >= 1, message: 'Should display field error messages' }
                    ];
                }
            }
        ];
        
        // Test runner functions
        async function runTest(test) {
            try {
                // Reset state before each test
                window.currentEditDeviceId = null;
                clearValidationErrors();
                document.getElementById('save-status').textContent = '';
                document.getElementById('save-status').className = '';
                document.getElementById('save-config-btn').disabled = false;
                document.getElementById('save-config-btn').textContent = 'Save Configuration';
                
                const assertions = await test.test();
                const passed = assertions.filter(a => a.condition).length;
                const total = assertions.length;
                
                return {
                    name: test.name,
                    passed: passed === total,
                    assertions: assertions,
                    passedCount: passed,
                    totalCount: total,
                    error: null
                };
            } catch (error) {
                return {
                    name: test.name,
                    passed: false,
                    assertions: [],
                    passedCount: 0,
                    totalCount: 1,
                    error: error.message
                };
            }
        }
        
        async function runAllTests() {
            document.getElementById('server-status').textContent = 'Running tests...';
            testResults = [];
            
            for (const test of tests) {
                const result = await runTest(test);
                testResults.push(result);
            }
            
            displayResults();
            document.getElementById('server-status').textContent = 'Tests completed';
        }
        
        function displayResults() {
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = '';
            
            testResults.forEach(result => {
                const testDiv = document.createElement('div');
                testDiv.className = `test ${result.passed ? 'pass' : 'fail'}`;
                
                let assertionsHtml = '';
                if (result.assertions.length > 0) {
                    assertionsHtml = result.assertions.map(assertion => 
                        `<li style="color: ${assertion.condition ? 'green' : 'red'};">${assertion.message}</li>`
                    ).join('');
                }
                
                testDiv.innerHTML = `
                    <h3>${result.name} ${result.passed ? '✅' : '❌'}</h3>
                    <p>Passed: ${result.passedCount}/${result.totalCount}</p>
                    ${result.error ? `<p style="color: red;">Error: ${result.error}</p>` : ''}
                    ${assertionsHtml ? `<ul>${assertionsHtml}</ul>` : ''}
                `;
                
                resultsDiv.appendChild(testDiv);
            });
            
            // Summary
            const passed = testResults.filter(r => r.passed).length;
            const total = testResults.length;
            const summaryDiv = document.createElement('div');
            summaryDiv.className = `test ${passed === total ? 'pass' : 'fail'}`;
            summaryDiv.innerHTML = `<h2>Test Summary: ${passed}/${total} tests passed</h2>`;
            resultsDiv.insertBefore(summaryDiv, resultsDiv.firstChild);
        }
        
        function clearResults() {
            document.getElementById('test-results').innerHTML = '';
            testResults = [];
        }
        
        // Extract the validateAndSaveDeviceConfig function
        function getValidateAndSaveDeviceConfigFunction() {
            return \`
        async function validateAndSaveDeviceConfig() {
            if (!window.currentEditDeviceId) {
                console.error('No device ID available for saving');
                document.getElementById('save-status').textContent = 'Error: No device selected for saving';
                document.getElementById('save-status').className = 'error';
                return;
            }

            console.log(\`Starting save process for device \${window.currentEditDeviceId}...\`);

            const saveButton = document.getElementById('save-config-btn');
            const statusElement = document.getElementById('save-status');
            
            // Clear any previous validation errors
            clearValidationErrors();
            
            // Disable save button and show loading state
            saveButton.disabled = true;
            saveButton.textContent = 'Validating...';
            statusElement.textContent = 'Validating configuration...';
            statusElement.className = 'pending';

            try {
                // Collect form data into typed configuration structure
                console.log('Collecting form data...');
                const configuration = collectFormData();
                console.log('Collected configuration:', configuration);
                
                // Step 1: Validate configuration
                console.log('Validating configuration...');
                const validationResponse = await fetch(\`\${API_BASE}/configuration/validate-typed\`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        configuration: configuration,
                        validation_level: 'basic',
                        device_id: window.currentEditDeviceId
                    })
                });

                if (!validationResponse.ok) {
                    let errorMessage;
                    try {
                        const errorData = await validationResponse.text();
                        errorMessage = \`Validation request failed (\${validationResponse.status}): \${errorData}\`;
                    } catch {
                        errorMessage = \`Validation request failed: \${validationResponse.status} \${validationResponse.statusText}\`;
                    }
                    throw new Error(errorMessage);
                }

                const validationResult = await validationResponse.json();
                console.log('Validation result:', validationResult);
                
                // Handle validation warnings (show but don't block save)
                if (validationResult.warnings && validationResult.warnings.length > 0) {
                    displayValidationWarnings(validationResult.warnings);
                }
                
                // Handle validation errors (block save)
                if (!validationResult.valid && validationResult.errors && validationResult.errors.length > 0) {
                    displayValidationErrors(validationResult.errors);
                    statusElement.textContent = \`Validation failed: \${validationResult.errors.length} error(s) found\`;
                    statusElement.className = 'error';
                    return; // Don't proceed with save
                }

                // Step 2: Save configuration
                console.log('Saving configuration...');
                saveButton.textContent = 'Saving...';
                statusElement.textContent = 'Saving configuration...';
                
                const saveResponse = await fetch(\`\${API_BASE}/devices/\${window.currentEditDeviceId}/config/typed\`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        configuration: configuration,
                        validation_level: 'basic'
                    })
                });

                if (!saveResponse.ok) {
                    let errorMessage;
                    try {
                        const errorData = await saveResponse.text();
                        errorMessage = \`Save failed (\${saveResponse.status}): \${errorData}\`;
                    } catch {
                        errorMessage = \`Save failed: \${saveResponse.status} \${saveResponse.statusText}\`;
                    }
                    throw new Error(errorMessage);
                }

                const saveResult = await saveResponse.json();
                console.log('Save result:', saveResult);

                // Success
                const warningText = validationResult.warnings && validationResult.warnings.length > 0 
                    ? \` (\${validationResult.warnings.length} warning(s))\` 
                    : '';
                statusElement.textContent = \`Configuration saved successfully!\${warningText}\`;
                statusElement.className = 'success';
                
                console.log(\`Successfully saved configuration for device \${window.currentEditDeviceId}\`);
                
                // Refresh device list to show updated data
                setTimeout(() => {
                    console.log('Refreshing device list...');
                    loadDevices();
                }, 1500);

                // Auto-close modal after successful save (optional)
                setTimeout(() => {
                    if (confirm('Configuration saved successfully. Close edit window?')) {
                        closeModal('editDeviceModal');
                    }
                }, 2000);

            } catch (error) {
                console.error('Error saving configuration:', error);
                statusElement.textContent = \`Error: \${error.message}\`;
                statusElement.className = 'error';
            } finally {
                // Re-enable save button
                saveButton.disabled = false;
                saveButton.textContent = 'Save Configuration';
            }
        }\`;
        }
    </script>
</body>
</html>